<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UptimeRobot Dashboard</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1e1e1e;
            color: #e0e0e0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }
        .logo {
            font-size: 24px;
            font-weight: bold;
            color: #0078d4;
        }
        .status-summary {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
        }
        .status-card {
            flex: 1;
            margin: 0 10px;
            padding: 15px;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            background-color: #2d2d2d;
            text-align: center;
        }
        .status-card.up {
            border-left: 5px solid #4caf50;
        }
        .status-card.down {
            border-left: 5px solid #f44336;
        }
        .status-card.paused {
            border-left: 5px solid #ff9800;
        }
        .status-card h3 {
            margin-top: 0;
            font-size: 16px;
            color: #aaa;
        }
        .status-card .count {
            font-size: 32px;
            font-weight: bold;
            margin: 10px 0;
        }
        .monitors-list {
            background-color: #2d2d2d;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .monitors-list table {
            width: 100%;
            border-collapse: collapse;
        }
        .monitors-list th {
            text-align: left;
            padding: 12px 15px;
            background-color: #333;
            font-weight: 600;
        }
        .monitors-list td {
            padding: 12px 15px;
            border-top: 1px solid #444;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-up { background-color: #4caf50; }
        .status-down { background-color: #f44336; }
        .status-paused { background-color: #ff9800; }
        .refresh-btn {
            background-color: #0078d4;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .refresh-btn:hover {
            background-color: #005a9e;
        }
        .error-message {
            background-color: #5e0000;
            color: #ff9999;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: none;
        }
        .loading {
            text-align: center;
            padding: 30px;
            font-size: 18px;
            color: #aaa;
        }
        .uptime-bar {
            height: 8px;
            background-color: #444;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
        }
        .uptime-value {
            height: 100%;
            background-color: #4caf50;
        }
        .last-check {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        .last-updated {
            text-align: right;
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        .down-monitors {
            margin-top: 20px;
            background-color: #442222;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            display: none;
        }
        .down-monitors h3 {
            color: #f44336;
            margin-top: 0;
            margin-bottom: 10px;
        }
        .down-monitors ul {
            margin: 0;
            padding-left: 20px;
        }
        .down-monitors li {
            margin-bottom: 5px;
        }
        #debugInfo {
            margin-top: 20px;
            padding: 10px;
            background-color: #333;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <div class="logo">UptimeRobot Integration</div>
        <button id="refreshBtn" class="refresh-btn">Refresh Data</button>
    </div>

    <div id="errorMessage" class="error-message"></div>

    <div id="downMonitors" class="down-monitors">
        <h3>⚠️ Down Monitors</h3>
        <ul id="downMonitorsList"></ul>
    </div>

    <!-- Search and Filter Options -->
    <div style="margin: 20px 0; display: flex; justify-content: space-between; align-items: center;">
        <div>
            <input type="text" id="searchMonitors" placeholder="Search monitors..." style="padding: 8px; background: #333; color: #e0e0e0; border: 1px solid #555; border-radius: 4px; width: 250px;">
        </div>
        <div>
            <select id="statusFilter" style="padding: 8px; background: #333; color: #e0e0e0; border: 1px solid #555; border-radius: 4px; margin-right: 10px;">
                <option value="all">All Statuses</option>
                <option value="up">Up</option>
                <option value="down">Down</option>
                <option value="paused">Maintenance</option>
            </select>
            <select id="typeFilter" style="padding: 8px; background: #333; color: #e0e0e0; border: 1px solid #555; border-radius: 4px;">
                <option value="all">All Types</option>
                <option value="1">HTTP(S)</option>
                <option value="2">Keyword</option>
                <option value="3">Ping</option>
                <option value="4">Port</option>
                <option value="5">Heartbeat</option>
            </select>
        </div>
    </div>

    <div id="dashboard">
        <div class="status-summary" id="statusSummary">
            <div class="status-card up">
                <h3>Up</h3>
                <div class="count" id="upCount">0</div>
            </div>
            <div class="status-card down">
                <h3>Down</h3>
                <div class="count" id="downCount">0</div>
            </div>
            <div class="status-card paused">
                <h3>Maintenance</h3>
                <div class="count" id="pausedCount">0</div>
            </div>
            <div class="status-card">
                <h3>Total Monitors</h3>
                <div class="count" id="totalCount">0</div>
            </div>
        </div>

        <div class="monitors-list" id="monitorsList">
            <div id="loading" class="loading">Loading monitors data...</div>
            <table id="monitorsTable" style="display: none;">
                <thead>
                <tr>
                    <th>Monitor Name</th>
                    <th>Type</th>
                    <th>Status</th>
                    <th>Uptime</th>
                    <th>Last Check</th>
                </tr>
                </thead>
                <tbody id="monitorsTableBody">
                </tbody>
            </table>
            <div class="last-updated" id="lastUpdated"></div>
        </div>

        <!-- Incident History Section -->
        <div class="monitors-list" id="incidentHistory" style="margin-top: 30px;">
            <h3 style="padding: 15px; margin: 0; border-bottom: 1px solid #444;">Recent Incidents</h3>
            <div id="incidentHistoryLoading" class="loading">Loading incident history...</div>
            <div id="incidentList" style="padding: 15px;"></div>
        </div>

        <!-- Response Time Graph Section -->
        <div class="monitors-list" id="responseTimeGraphSection" style="margin-top: 30px;">
            <h3 style="padding: 15px; margin: 0; border-bottom: 1px solid #444;">Response Time Trends</h3>
            <div style="padding: 15px;">
                <select id="monitorSelector" style="padding: 8px; background: #333; color: #e0e0e0; border: 1px solid #555; border-radius: 4px; margin-bottom: 15px;">
                    <option value="">Select a monitor</option>
                </select>
                <div id="responseTimeGraph" style="height: 300px; background: #2d2d2d;"></div>
            </div>
        </div>

        <!-- Settings Section -->
        <div class="monitors-list" id="settingsSection" style="margin-top: 30px;">
            <h3 style="padding: 15px; margin: 0; border-bottom: 1px solid #444;">Dashboard Settings</h3>
            <div style="padding: 15px;">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">Auto-refresh interval (seconds)</label>
                    <input type="number" id="refreshInterval" min="30" value="60" style="padding: 8px; background: #333; color: #e0e0e0; border: 1px solid #555; border-radius: 4px; width: 100px;">
                    <button id="saveRefreshInterval" class="refresh-btn" style="margin-left: 10px;">Save</button>
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">Notification Sound</label>
                    <select id="notificationSound" style="padding: 8px; background: #333; color: #e0e0e0; border: 1px solid #555; border-radius: 4px;">
                        <option value="none">None</option>
                        <option value="beep">Beep</option>
                        <option value="chime">Chime</option>
                    </select>
                    <button id="testSound" class="refresh-btn" style="margin-left: 10px;">Test</button>
                </div>
            </div>
        </div>

        <div id="debugInfo"></div>
    </div>
</div>

<script>
    // Your UptimeRobot API key (read-only)
    const API_KEY = 'ur2875017-118b6389ec2262a9135b7929';

    // Status and Type Mappings
    const STATUS_MAP = {
        0: { text: 'Paused', class: 'status-paused' },
        1: { text: 'Not checked yet', class: 'status-paused' },
        2: { text: 'Up', class: 'status-up' },
        8: { text: 'Seems Down', class: 'status-down' },
        9: { text: 'Down', class: 'status-down' }
    };

    const TYPE_MAP = {
        1: 'HTTP(S)',
        2: 'Keyword',
        3: 'Ping',
        4: 'Port',
        5: 'Heartbeat'
    };

    // DOM Elements
    const errorMessage = document.getElementById('errorMessage');
    const refreshBtn = document.getElementById('refreshBtn');
    const loading = document.getElementById('loading');
    const monitorsTable = document.getElementById('monitorsTable');
    const monitorsTableBody = document.getElementById('monitorsTableBody');
    const upCount = document.getElementById('upCount');
    const downCount = document.getElementById('downCount');
    const pausedCount = document.getElementById('pausedCount');
    const totalCount = document.getElementById('totalCount');
    const lastUpdated = document.getElementById('lastUpdated');
    const debugInfo = document.getElementById('debugInfo');
    const downMonitorsDiv = document.getElementById('downMonitors');
    const downMonitorsList = document.getElementById('downMonitorsList');

    // Notification system variables
    let notificationSound = 'none';
    let notificationAudio = new Audio();
    let previousStatus = {}; // To track status changes

    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', function() {
        fetchMonitors();
        fetchIncidentHistory();
        initNotifications();
        initFilterAndSearch();

        // Auto-refresh data every 1 minute
        setInterval(fetchMonitors, 60000);
    });

    // Event Listeners
    refreshBtn.addEventListener('click', fetchMonitors);

    // Function to fetch monitors data
    async function fetchMonitors() {
        // Reset UI
        errorMessage.style.display = 'none';
        loading.style.display = 'block';
        monitorsTable.style.display = 'none';
        downMonitorsDiv.style.display = 'none';

        try {
            // Create API request data
            const formData = new FormData();
            formData.append('api_key', API_KEY);
            formData.append('format', 'json');
            formData.append('all_time_uptime_ratio', '1');
            formData.append('response_times', '1');
            formData.append('logs', '1');
            formData.append('response_times_limit', '1'); 
            formData.append('alert_contacts', '1');

            // Make the API request directly
            const response = await fetch('https://api.uptimerobot.com/v2/getMonitors', {
                method: 'POST',
                body: formData
            });

            // Parse response
            const data = await response.json();

            // Debug data
            console.log('API Response:', data);

            // Check if the response is valid
            if (data && data.stat === 'ok') {
                renderMonitors(data.monitors);
                updateLastUpdated();
                updateMonitorSelector(data.monitors);
                checkStatusChanges(data.monitors);
            } else {
                throw new Error('Invalid response from UptimeRobot API');
            }
        } catch (error) {
            showError(`Failed to fetch monitor data: ${error.message}`);
        } finally {
            loading.style.display = 'none';
        }
    }

    // Function to render monitors data
    function renderMonitors(monitors) {
        if (!monitors || !Array.isArray(monitors)) {
            showError('Invalid data format received from API');
            return;
        }

        // Debug the monitors data
        console.log('Monitors data:', monitors);

        // Clear tables and lists
        monitorsTableBody.innerHTML = '';
        downMonitorsList.innerHTML = '';

        // Count different statuses
        let upCounter = 0;
        let downCounter = 0;
        let pausedCounter = 0;
        let hasDownMonitors = false;

        // Process and display each monitor
        monitors.forEach(monitor => {
            console.log(`Monitor ${monitor.friendly_name} last_check:`, monitor.last_check);
            // Update counters
            if (monitor.status === 2) upCounter++;
            else if (monitor.status === 8 || monitor.status === 9) {
                downCounter++;
                hasDownMonitors = true;

                // Add to down monitors list
                const li = document.createElement('li');
                li.textContent = `${monitor.friendly_name} (${monitor.url})`;
                downMonitorsList.appendChild(li);
            }
            else pausedCounter++;

            // Create table row
            const row = document.createElement('tr');

            // Format last check time
            let lastCheckFormatted = 'N/A';
            if (monitor.last_check) {
                const lastCheck = new Date(monitor.last_check * 1000);
                lastCheckFormatted = lastCheck.toLocaleString();
            }

            // Calculate uptime percentage
            const uptimePercent = parseFloat(monitor.all_time_uptime_ratio) || 0;

            // Build row content
            row.innerHTML = `
                <td>${monitor.friendly_name}</td>
                <td>${TYPE_MAP[monitor.type] || 'Unknown'}</td>
                <td>
                    <span class="status-indicator ${STATUS_MAP[monitor.status].class}"></span>
                    ${STATUS_MAP[monitor.status].text}
                </td>
                <td>
                    <div>${uptimePercent.toFixed(2)}%</div>
                    <div class="uptime-bar">
                        <div class="uptime-value" style="width: ${uptimePercent}%"></div>
                    </div>
                </td>
                <td>
                    <div>${lastCheckFormatted}</div>
                    <div class="last-check">Response: ${monitor.average_response || 'N/A'} ms</div>
                </td>
            `;

            // Highlight down rows
            if (monitor.status === 8 || monitor.status === 9) {
                row.style.backgroundColor = '#3a2222';
            }

            monitorsTableBody.appendChild(row);
        });

        // Update summary counters
        upCount.textContent = upCounter;
        downCount.textContent = downCounter;
        pausedCount.textContent = pausedCounter;
        totalCount.textContent = monitors.length;

        // Show down monitors section if there are any
        if (hasDownMonitors) {
            downMonitorsDiv.style.display = 'block';
        }

        // Show table
        monitorsTable.style.display = 'table';
    }

    // Function to check for status changes and notify
    function checkStatusChanges(monitors) {
        monitors.forEach(monitor => {
            const monitorId = monitor.id;

            // If we have previous status for this monitor
            if (previousStatus[monitorId] !== undefined) {
                const oldStatus = previousStatus[monitorId];
                const newStatus = monitor.status;

                // If status changed from up to down
                if ((oldStatus === 2) && (newStatus === 8 || newStatus === 9)) {
                    showNotification(
                        'Monitor Down!',
                        `${monitor.friendly_name} is down. Status: ${STATUS_MAP[newStatus].text}`
                    );
                }
                // If status changed from down to up
                else if ((oldStatus === 8 || oldStatus === 9) && (newStatus === 2)) {
                    showNotification(
                        'Monitor Recovered!',
                        `${monitor.friendly_name} is back up.`
                    );
                }
            }

            // Update previous status
            previousStatus[monitorId] = monitor.status;
        });
    }

    // Function to display errors
    function showError(message) {
        errorMessage.textContent = message;
        errorMessage.style.display = 'block';
    }

    // Function to update last updated timestamp
    function updateLastUpdated() {
        const now = new Date();
        lastUpdated.textContent = `Last updated: ${now.toLocaleString()}`;
    }

    // Function to update monitor selector dropdown
    function updateMonitorSelector(monitors) {
        const selector = document.getElementById('monitorSelector');

        // Clear existing options except the first one
        while (selector.options.length > 1) {
            selector.remove(1);
        }

        // Add monitors to selector
        monitors.forEach(monitor => {
            const option = document.createElement('option');
            option.value = monitor.id;
            option.textContent = monitor.friendly_name;
            selector.appendChild(option);
        });

        // Add event listener if not already added
        if (!selector.hasAttribute('data-event-added')) {
            selector.addEventListener('change', function() {
                if (this.value) {
                    renderResponseTimeGraph(this.value);
                }
            });
            selector.setAttribute('data-event-added', 'true');
        }
    }

    // Function to render response time graph
    function renderResponseTimeGraph(monitorId) {
        const graphContainer = document.getElementById('responseTimeGraph');
        graphContainer.innerHTML = '<div class="loading">Loading response time data...</div>';

        // In a real implementation, you'd fetch response time data from the API
        // For demo purposes, we'll create mock data
        setTimeout(() => {
            // Mock data - replace with real API call
            const responseTimeData = [
                { date: '2023-04-01', responseTime: 420 },
                { date: '2023-04-02', responseTime: 380 },
                { date: '2023-04-03', responseTime: 450 },
                { date: '2023-04-04', responseTime: 390 },
                { date: '2023-04-05', responseTime: 410 },
                { date: '2023-04-06', responseTime: 400 },
                { date: '2023-04-07', responseTime: 360 }
            ];

            // Clear the container
            graphContainer.innerHTML = '';

            // Create simple bar chart
            const maxResponseTime = Math.max(...responseTimeData.map(d => d.responseTime));
            const chart = document.createElement('div');
            chart.style.display = 'flex';
            chart.style.alignItems = 'flex-end';
            chart.style.height = '250px';
            chart.style.padding = '10px 0';

            responseTimeData.forEach(data => {
                const barHeight = (data.responseTime / maxResponseTime) * 200;

                const barContainer = document.createElement('div');
                barContainer.style.flex = '1';
                barContainer.style.margin = '0 5px';
                barContainer.style.textAlign = 'center';

                const bar = document.createElement('div');
                bar.style.height = `${barHeight}px`;
                bar.style.backgroundColor = '#0078d4';
                bar.style.margin = '0 auto';
                bar.style.width = '30px';
                bar.style.borderRadius = '3px 3px 0 0';

                const tooltip = document.createElement('div');
                tooltip.style.marginTop = '10px';
                tooltip.style.fontSize = '12px';
                tooltip.textContent = `${data.responseTime}ms`;

                const dateLabel = document.createElement('div');
                dateLabel.style.marginTop = '5px';
                dateLabel.style.fontSize = '10px';
                dateLabel.style.color = '#888';
                dateLabel.textContent = data.date.split('-')[2]; // Just show day

                barContainer.appendChild(bar);
                barContainer.appendChild(tooltip);
                barContainer.appendChild(dateLabel);
                chart.appendChild(barContainer);
            });

            // Add title and axis labels
            const title = document.createElement('div');
            title.style.textAlign = 'center';
            title.style.marginBottom = '20px';
            title.style.fontWeight = 'bold';
            title.textContent = 'Response Time (Last 7 Days)';

            const yAxis = document.createElement('div');
            yAxis.style.position = 'absolute';
            yAxis.style.left = '10px';
            yAxis.style.top = '50%';
            yAxis.style.transform = 'rotate(-90deg) translateX(-50%)';
            yAxis.style.transformOrigin = 'left top';
            yAxis.style.fontSize = '12px';
            yAxis.style.color = '#888';
            yAxis.textContent = 'Response Time (ms)';

            const xAxis = document.createElement('div');
            xAxis.style.textAlign = 'center';
            xAxis.style.marginTop = '10px';
            xAxis.style.fontSize = '12px';
            xAxis.style.color = '#888';
            xAxis.textContent = 'Date';

            const chartContainer = document.createElement('div');
            chartContainer.style.position = 'relative';
            chartContainer.appendChild(title);
            chartContainer.appendChild(chart);
            chartContainer.appendChild(xAxis);
            chartContainer.appendChild(yAxis);

            graphContainer.appendChild(chartContainer);
        }, 1000);
    }

    // Function to fetch and display incident history
    function fetchIncidentHistory() {
        document.getElementById('incidentHistoryLoading').style.display = 'block';
        document.getElementById('incidentList').innerHTML = '';

        // Here you would make an API call to get incident logs
        // For demo purposes, we'll create mock data
        setTimeout(() => {
            document.getElementById('incidentHistoryLoading').style.display = 'none';

            const incidents = [
                { monitor: 'Main Website', time: '2023-04-03 14:23', duration: '5m 12s', reason: 'Connection timeout' },
                { monitor: 'API Server', time: '2023-04-02 08:45', duration: '12m 30s', reason: 'HTTP 500 error' },
                { monitor: 'Database Server', time: '2023-04-01 22:10', duration: '3m 45s', reason: 'Connection refused' }
            ];

            const incidentList = document.getElementById('incidentList');

            if (incidents.length === 0) {
                incidentList.innerHTML = '<p>No incidents in the last 7 days.</p>';
                return;
            }

            const table = document.createElement('table');
            table.style.width = '100%';
            table.style.borderCollapse = 'collapse';

            // Create header
            const thead = document.createElement('thead');
            thead.innerHTML = `
                <tr>
                    <th style="text-align: left; padding: 10px; border-bottom: 1px solid #444;">Monitor</th>
                    <th style="text-align: left; padding: 10px; border-bottom: 1px solid #444;">Time</th>
                    <th style="text-align: left; padding: 10px; border-bottom: 1px solid #444;">Duration</th>
                    <th style="text-align: left; padding: 10px; border-bottom: 1px solid #444;">Reason</th>
                </tr>
            `;
            table.appendChild(thead);

            // Create body
            const tbody = document.createElement('tbody');
            incidents.forEach(incident => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td style="padding: 10px; border-bottom: 1px solid #333;">${incident.monitor}</td>
                    <td style="padding: 10px; border-bottom: 1px solid #333;">${incident.time}</td>
                    <td style="padding: 10px; border-bottom: 1px solid #333;">${incident.duration}</td>
                    <td style="padding: 10px; border-bottom: 1px solid #333;">${incident.reason}</td>
                `;
                tbody.appendChild(row);
            });
            table.appendChild(tbody);

            incidentList.appendChild(table);
        }, 1000);
    }

    // Function to initialize notification system
    function initNotifications() {
        // Set up notification permissions if browser supports it
        if ('Notification' in window) {
            if (Notification.permission !== 'granted' && Notification.permission !== 'denied') {
                Notification.requestPermission();
            }
        }

        // Initialize audio for sound notifications
        document.getElementById('notificationSound').addEventListener('change', function() {
            notificationSound = this.value;
            localStorage.setItem('uptimeRobotNotificationSound', notificationSound);
        });

        document.getElementById('testSound').addEventListener('click', function() {
            playNotificationSound();
        });

        // Load saved settings
        const savedSound = localStorage.getItem('uptimeRobotNotificationSound');
        if (savedSound) {
            notificationSound = savedSound;
            document.getElementById('notificationSound').value = savedSound;
        }
    }

    // Function to play notification sound
    function playNotificationSound() {
        if (notificationSound === 'none') return;

        if (notificationSound === 'beep') {
            notificationAudio.src = 'https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3';
        } else if (notificationSound === 'chime') {
            notificationAudio.src = 'https://assets.mixkit.co/active_storage/sfx/1630/1630-preview.mp3';
        }

        notificationAudio.play().catch(e => console.error('Error playing notification:', e));
    }

    // Function to show notification
    function showNotification(title, message) {
        // Play sound
        playNotificationSound();

        // Browser notification
        if ('Notification' in window && Notification.permission === 'granted') {
            new Notification(title, {
                body: message,
                icon: '/favicon.ico'
            });
        }
    }

    // Add filter and search functionality
    function initFilterAndSearch() {
        const searchInput = document.getElementById('searchMonitors');
        const statusFilter = document.getElementById('statusFilter');
        const typeFilter = document.getElementById('typeFilter');

    function applyFilters() {
        const searchTerm = searchInput.value.toLowerCase();
        const statusValue = statusFilter.value;
        const typeValue = typeFilter.value;

        const rows = monitorsTableBody.querySelectorAll('tr');

        rows.forEach(row => {
            const monitorName = row.cells[0].textContent.toLowerCase();
            const monitorType = row.cells[1].textContent;
            const monitorStatus = row.cells[2].textContent.trim();

            // Check search term
            const matchesSearch = searchTerm === '' || monitorName.includes(searchTerm);

            // Check status filter
            let matchesStatus = true;
            if (statusValue !== 'all') {
                if (statusValue === 'up' && !monitorStatus.includes('Up')) matchesStatus = false;
                if (statusValue === 'down' && !(monitorStatus.includes('Down') || monitorStatus.includes('Seems Down'))) matchesStatus = false;
                if (statusValue === 'paused' && !(monitorStatus.includes('Paused') || monitorStatus.includes('Not checked'))) matchesStatus = false;
            }

            // Check type filter
            let matchesType = true;
            if (typeValue !== 'all') {
                const typeId = Object.keys(TYPE_MAP).find(key => TYPE_MAP[key] === monitorType);
                if (typeId !== typeValue) matchesType = false;
            }

            // Show/hide row based on filters
            if (matchesSearch && matchesStatus && matchesType) {
                row.style.display = '';
            } else {
                row.style.display = 'none';
            }
        });
    }

    // Add event listeners
    searchInput.addEventListener('input', applyFilters);
    statusFilter.addEventListener('change', applyFilters);
    typeFilter.addEventListener('change', applyFilters);
}



</script>
</body>
</html>
